<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Product Ordering Tool</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-page {
                width: 100%;
                padding: 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-page .locked {
                width: 1.1rem;
                margin-right: 0.5rem;
            }

            .staticrypt-form {
                position: absolute;
                z-index: 1;
                background: #212121;
                color: #eeeeee;
                width: 360px;
                top: 50%;
                left: 50%;
                margin-right: -50%;
                transform: translate(-50%, -50%);
                padding: 2rem;
                text-align: left;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                color: #eeeeee;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 0.9rem;
                outline: 0;
                padding: 1rem 2rem 1rem 1rem; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                width: 100%;
                border: 1px solid #616161;
                margin: 0 0 1rem;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
                filter: invert(100%) sepia(0%) saturate(7466%) hue-rotate(299deg) brightness(123%) contrast(87%);
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #eeeeee;
                width: 100%;
                border: 0;
                border-radius: 0;
                padding: 0.9rem;
                color: #1a1a1a;
                font-size: 0.9rem;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active {
                background: #eaeaea;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
                font-family: "Circular STD", "Gotham HTF", "SF Pro", "Arial", sans-serif;
            }

            .staticrypt-body {
                width: 100%;
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1rem;
                background: #1a1a1a;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                width: 100%;
                display: inline-flex;
                align-items: center;
                margin-top: -1rem;
                margin-bottom: 0.5rem;
            }

            .staticrypt-title {
                font-size: 1rem;
                color: #eeeeee;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .error {
                display: block !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            #invalidPass {
                display: none;
                color: #ff5555;
                margin-top: 1rem;
            }

            .nav {
                box-sizing: border-box;
                position: absolute;
                display: inline-flex;
                align-items: center;
                justify-content: space-between;
                width: 100%;
                padding: 2rem calc(2rem + 4vw);
            }

            .logo {
                width: 2.1rem;
                padding: 0;
            }

            .nav-row {
                float: right;
            }

            nav a {
                text-transform: uppercase;
                font-size: 0.95rem;
                font-weight: 600;
                margin-right: 1.5rem;
                color: #757575;
                text-decoration: none;
                line-height: 1.5rem;
            }
            
            nav a:hover {
                color: #eeeeee;
            }

            nav a:nth-last-of-type(1) {
                margin-right: 0;
            }

            @media (max-width: 26.75em) {                
                .nav {
                    justify-content: center;
                }

                .nav-row {
                    width: 90%;
                    display: inline-flex;
                    justify-content: space-between;
                }

                nav a {
                    font-size: 1.1rem;
                }

                .desktop {
                    display: none;
                }

                .staticrypt-form {
                    width: 70vw;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <header class="nav">
			<a href="index.html">
                <img class="logo desktop" src="img/favicon.png">
            </a>
			<nav class="nav-row">
				<a href="index.html">Work</a>
				<a href="ideas.html">Ideas</a>
				<a href="about.html">About</a>
			</nav>
		</header>

        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <img class="locked" src="img/lock-icon.svg" alt="Password protected">
                        <p class="staticrypt-title">This page is password protected</p>
                        <p></p>
                    </div>

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="ENTER" />

                        <span id="invalidPass" class="error">Incorrect password, please try again</span>
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ec4e71b621f4e77a0848cf9d9b8643175499c88e94ea14359c6767e8a759d081dce5494f4eb20fa3a75a91994a24b4954b4c65b93932829fc0ad0e796b807a220fb6114c6beeb75592ce601fbaa313fd137f4b81766fef84b5c7a8bc2172bd404194165e8a1a0d8280af8ea28eba96afed42b29bea4d0d2fb606a004113870a3db87b430b9daf76ecdb39c2e7a4bbee30682189b80e5b1ac9f040980ef535a131ea5497eb67094560aa4ec34839d5a669f81527e3723247b33245ada961cae58d37a75aec5b037251d7560f21b8ef654ddc3b606cf6b25699287f00ee6610ed61a786acbf85b0367b378ca1e20485028980b1118d786793ad7f307691413294fe630b9b55b13a983f5a5318f187b5f2e3acf3c97b2b5fe97bd6e6cc890406b752569cdd7c723f1ad4847f28fdbea4b919832642779b5d4c98139d3ec002884e130fe1d0c18167ae292a9bb1db48f918b4bcccec5d80f0cef02a28291cb158da06c8d74e448ae9d95b751ac5f6a49e38c254ff7a9792323888dd4e5f99358872d4ff5b121ad4f72c8fcde695593c6829efe4beb43e692465ac32862f1654dc1d209e46be1514cbd3276a21ab9daa01545e649f3dcf61095736f5814c7614b955761058e844d9cdf4f5f9a0a384bbb4c77bd9577260d15e99f8977a661786b2e9d2ae6ec617e394d562dfbd1ebc83e850692c0954d60b8a669bc75782fc4014740f1cc5c3b2a7ad0cefc08395e9e2337f9d5ab2b7affec67995e5597cf9e7cc44042dc93c7390320bd9c410fb5ebfc2d80db22e894af462615be27d35a7b5186067b9ec13b9cfa9308076abc979a078683e63e24279a292b9330aa10406b453a2ed431497be279b2e4bb68cd3801897f14dae14ff744f552e61214890cd72baad2568c67d59fcff6e8179cac7f93cff179e59a95d002b6ff54fdcf22842c239829335753cf089890087f96073b57e78d219d189d72796eca91fa6ea38e33247badacfec74c4b3732b57580fe3ea2120b4ff3e62d8dea429b687e0e4c3a46fd4ea6534bf48191d0e962bd153fedb01cf85363f905e9558a174cc80ebe734cfa16b273e2f674510e840cbfada4a43c7d7aecd4aab87ba98b90deadd0b18e57e6f67a7ec700c03daf32a4644a6f27eca4d5e8823fa571c954fd2d22a1d630537fd5bbd5214fbe530813d2e034c718cdc414b55047882d53243ea21e7bfd4d6c0765587452f474df5e2f9fa3e83d6992a64a7a2f9ec146b26a0e870cd10130b3d12b24e41e58bb5806bf036ce5dce90b03b736b1cf123e8cacb4a5fa9d9ab3479875e6c075a9821c2da6af0835461157028381f15de89b733d43db97cdb157bb403984167a6780ccb13c45c79a09b45605f3394a12e48c66486f2e9f564234cc076488daf0d7f9814f901c931f7d2b02f907616df2cfa9b3c52ce366f86c754c57e6fc45fa2f725cbda77f48dea42f6c0942310a3be5a4089ef44ba7fd3fb419bf8659027c4154b1fd91f7317e5f5e27bb08014bc7c98d2ee4d8322c892be2877479488ccd6c45557dc30b839f0e9a5ed4615e0179a594b7a7bfdf5d0f44b7a5977ecf3fed01fb0b38947cf8e6680e0aa5f503494d0e5df7135d18eea076fdc5c8585d5abed429f4fb771cfa7fe6e6bdf29ebc796348f3b23ca78789ecffb11db9692a2696ce3b2ee24cc2afd0d4e9bf0833d4c30e8ff8ebe2cb198b07c3af9c468c6568d3a8a6303e7baa6bb161c2b1d411fe0ee655f04e9a79c5c89e299c737b0fe4068ed163931e11e86f1725ea9cbf17f4ce605867f6e789a0dc60f15a72e4b14e4c7c9bdfeb650e27cb60492e57ccf657fc5d7facc6196a22b30f51bc6c0ec4cf7851ba3a34f03c57ec90a95ef06664ed3588eb8d7350c8a32b0e8faa9956dee4f7c5b792db4742897549e658cdddb64aaeef96d6d91b1a5169e796bfeedaefb429e3f28ea97c1286668234731058bf1be5cd981c798e518bfcb81a0ebe445003d299f639a381a875586f5b581008445fb1adbe2ea7b515b06d63b26604a27f9f66f7f483866c6f33a8bebb4f05a3ff27466729309ac3a75e9cc23915bbb050227bea8c4a2e00d5661db5fee9bb7a925f4dae0fda38695628115fe82ddbe821a893b4a4994abd9e67b5871e3bfbbeb946d71037a6dc74295e80b6e8cf46d5222c038437eee9d65ecfc6b958a63ee0394d15ccf3899171f68438c50f8e9de91ab47d46b44b3454d6a7b05a6834a69697e9698a4d20b588d1df33d40354a5ba166b5734705d0d57263c540ab839af0033755efcbcc1775cd8294b10f7edd70305cc9b49def91af659b33715551321438b658b8637db3cd0e5dfc937915a4611b8dcf6590fde2583d603d307daa1edea79876436084a82cd7e07c62dbc98fc5852610dee7985075871f6b77046045328c546d0992851043c256d97ea91ac7e2ccca8fb6ee03e6b7ff6d280c00d46fb7ab6293c586793aaeb0f1e0e92c809af87a74a53b7ff4b5eb3286a6c8be9827536b4002c2fc645239fc98f8d47831aef8863b1fa0da65db0fbed8eb22174a6ff08b2e3ef3e81a297eb8055bb995ee6c3e547462e261c773be44ac968e32679000a490cc0db0b348ede759b2ec390b757e435423d2c1ad0c1ce202bf31a6b3cbad0db740dfac39fce43709b36eae8c892fbf43ca6f07982e6fbef7aec15a5588306439cf1bb0d13cfb41a20b4f5a4796a5ba5805ed769649bda254a0f8fc409dba726c89ad053fd06d0524fc237470e18dc2468ff5cb3bf82481f66b1a11b43d26402e7daf7243666cbd125716d593dc1730ff4f402541eeeeac7575f4003ab1c63b454f7334ba4f9032e6e6a148b743c056b561622ecdb90a23cf1bcd5019786253f36fa6acb2c63b2de137f8e1e5a8f530ecdca3de8c71118aba29817133355479eacd725fd246e0563f1eb62bde1adcdcffb7c009f09170940156f55d5bbebbcc12b9ac20127599db17f26af4e3bcef592a8e8de48cecee93cf4f934fd983e7b75b553ab40bb296011737dce9e4484281101a1f0a59ce40d4245f10424d5c542835d912536a70796517510772ca2acb593b1eb7faca2f241a66c91951e0d599a48d099b9d51942e006382823234d110dda2da2f47843c8b0aed66a1c7f5fde19557240ab92c40539a89026ddee563b123dfa4cb6135866df0ab165f9ceb52afc39cd488579c16d8aa6148ca485b6f118d01909f87e8a9577d7515be2fe30f547f16c96002694cb0cd31c2afb983f910c5c3da10916c93ef0a413a99dc3c0e6624fe8746cfc01f1f3650587f0c277e47d58fec8f2a9060383de6664b057b0f3fad91f75ea1d8cea2a54db2dcb4f3d4f79064ed4d2e26bc09237819b089f0c544e7c161567bff20d4a09ea0fa58cfe37015b48b84cf1cb2c81b533463652e0a657d207c22e03c3a814beec26c76ddb1f581d1cb3703c00b8d59a2e2d04de5788384d40d83a8c0c6b8bdd177552c4e424f9762a2f658cabb97e1095b0a953e02494dcff654dcba825494036ce066c3717f42c39f652081dfc635cc11a3b72a9488ffa2d424abe003311adc2c779a79e7188e81f987013ead21447515fa50be741696a1553302c33f16d7a0a14137c3bf2f75abff98491b18ee727f35fc8f9a09d400c1ca5d2f5042ef5161b8d9efb659948b0dc36806eadef94df8d30682085a77d93808a3fda19e2db42f08d11f5353dffdcbdfc312febbe5a4da1f264fe62941ee2bda25c5897c90ce041b4c603763a43ebe713d1d7ce5711020fd6a7358c6906671f0a5111898bcd5d0be937ac0c2d3e7e6199e3ced220fc4c51ae2b69227648a733621d8a817d7355bae908f9d74a135810afd1b20bd1f8635d7d868584816a47394b9446e7d73fd9feab86029d0a760f8d072c768940e3df5b8750831539ddb4c20f500cb2dbe173a1ab9ec5a22e02378f8da6a219873469bf21a54a464dddeda2b2c2f700555038bd99d993431290dccc8cb90ff252ebabef8868c49f45a9425fe77a4556fdaf32aa98f0da87d293670b742de684a79f5fd7ec518829ee275b4ae501ccebea79d905b367f90a22786a65adf5ac4e46de734682baa9f4bc8d3242e735354855b6f0cb74fecdcd9b53edb2c2dd1c380cfd5ea91b4a47eac5c94cfb467e0e4454adb7789a28795436da8377016af9d29172df5f5ff9485263a9bbe5b309a8d9b69fca6851ca48bbc0fe3b7c14288397a278c1358863de14b2fa814c2d427dee2dc5817459a23c34da247201850c0b62c39efa819c36377ee5dbbe552debd70eec3d8d62b2a494ce26bd5b504b9909c02a02b10c2cf2c6100e3c0fb4fdfb7c28cd95cb480387f0561049410deba413ae55b6350906643f85cf0bcc3ef40dc5ac978d699ce3fc86073e423a7149ec717dd016b0678ec954893c39db437aa30af24a081321dcb55af3a712c212b7e8ff3190bb20cb9682553046e17b10ef5d8979d88214f220325d684ae3070891659f442a94f4c8cbdc46a4f5a260ab4a039186eed3230a721ce614c264bc6956128e79d2de81cd4aeb6b8b0e45a408bba611cf37b561d52cb292ba4ea0c8a732e62874cfaa789c9499c42bf8df23669c2d23a345c2115d50ab5f75d4a2e51b59ad0c9cff170ef597283480d58ef80dd25aaf5fe841aad49f9ab1a98e409b1962a8ad866d9318c5c4243ae9b370ad8568e4da020d7d435752ef8acce41d717064400367ce6782af8bb1e849f3fedbdf78ad82886f6e87a493e397ffab6a17a8284a5d5ce263026e70302f27ca314eea39df308f9a0347ba0195a6aba88978b9bf7af77b1bab07d0b308da01f089f02d9f9c5ea0aee9894b02b8a1a01d26cd7daca7560f45ee7dae942dc3f76d407032580b011c277536151fb3398080ffb78ffab47b3037c77fa76cfcb82def5432b7ecc7732c6dbc83522aff1c965d068580732106a3819fe0b6ed823d378d39134f2edd8a42680243e883d226321bd10a729558eb211d12faa0fac9613f7be4873427010265f69818431eaf141eddfe5fe9bc4508b0682d39b393b7fb243f0af32b7bcea4bfe909dd3c497e2a82c48126d9ff84d64df1b7fd66f499fa3f5de116e0623e82488471d6fa28e94e3675bfc61692e0e0a8ce5feaed0c992f0924188c642474dc00936b5a302ad109e54d2cef7ab879d874dee98274cb2ed2c3d74e9e2b6e6a88375f5bfdc0c486329c61fe3ff460ca018c5779c7f369acdecd8ed33f700c3739ee5e6a99bdfd5da3a250cec9828e8b1b58128df5a0e54773c84f623713cc909040264281549acf6162f9793e99b0a2d55c25a673b71cd1e693132a0bf655fee7f59af0fc4020f7e9e2ef14386af02e8eb05adfbef6fbcbf7789af5cea9cf6f5ce4f3f257e65100339e235fa66594ae0c3af750830a0b327a575a939533fda6afc2d5c3c607a5560c051ce3a02a1dfae83d218a12a06db217e8ad3f30f1e2a06acdf37a454e60470a0138adc301f865394b19da2feb0a6c7f25a305f53580a59358c10f13eeb2aefdfaf149b4ac5f3155a7b889a719ebe70cc2bed9a3b1e47842e2ec96a2ca78b4506d44479c21b705b322e120ce58ccc67bd48e5191db0c47e4e99c928bed61304c773ccf38fe8b9b3be2a01e04ff62fda3fc0fc07dcb711b0579002a8c3765ba69421a1c3700e462cc4358386a9ce8a3b9fe2104e28d2c8219e9b7acd0b180a54eaef2a3a9118e80110c2b93377948fbfbdc3876b9932a7097c23a6413267da19633aee31cbc9433ac675e4d1a967ce8398b5ce581ae33ff9d7deb544696c1d7f6e915509562910c14142fcb7dacba12a0d4d96a2cc05bc428c4c6e7cad17e4ee1b19beb2d89005494fd5cbe7cff481573f8c9a2e18d44902decd74aeec93579fb1e2e7dba3c2f5eda5c67e2a927b1a9d3632dc16a7d90758b632a943c06b81580401318369a887812e8a481137be9a08b3bad4d50ebc935876ed09f6124c3b5ac956f025dd5d570e2fe9ee43b4a717dfac64a5be1496ffac98b4cc602112753a29763965c1138b6b80c7bef098e35b078e4e1dc7ef9e9e621e6e86b625e13c940a41648f1fde02e14459cedd350f789a7f709a5c278b39ad0f4412a323da3c986dccc73810f0075de0f5a7aa6d73ce5e27057e996ccccb0c1072fe7c6b660bc529c9021414153480d2e1f4b4edc162ae2c4e4e9daa338c6f3b735507436ae6e319a68c08372c2cc5a0460085b502fd50e421224652779216ee107a2bbf2fac7eb803e621e123e3d856e0d6467fc775492745b2d23415731d292de0ed11eeaf38afbb668131aa59e0127c0c7615a087cfacfadc8ae7328df35d98eb49588612898a81eec378fdaa1993747e99ff6f8ee5c31ba66f7c8052b245c216451afe67a95ac441fad11c531d9b8dc440c8290249de078a1d0d6669935b533fdf6be2a6c2dff7c6eb5ebeadf6a3d3f3176a4597f15b9b453c168abd531d258b39a622a262edc9fb6ffe97276495c96e1537fda0e8664bf0821d587f03cc7c2f3d272d5f8a8475418c58afb2ebeba5ae70c1fafe5636e2dc8db04f36bf5c49e1041fabeabcebf30883b198d89d51f59551b01c759ee36cbe3ce89b36433b10978c528df5ac18c3a803452b4edf75635ab8d64aeec504a710120234827e0dd3dbbef6cbc2ba086483a124989254aaae5c70e7b47607ec49e7c18b2bb24d9cbdbc1036716a0802f28472b7af9bc97a5b1660bfaa7c375c6052aaf9308ea4a2c6e7e840c698c1fcc638a7b285bff6e128bb20aa9ac9e47583b5487bcf510409f70a4f43d3a72e402be5c3f1962a28fc5a36e9fa19d475992cb0575ee2048b6db8a94c82df1ccc3625def524713203f592e33168d9b102f26a44f50493e4c2ffb9d2627a4fa083f3921bf7a1066b912f520d4a89171c958dffcd1b88e4e2e633e83fe09c18c7f4b7cfa43331ef99d755c5d1b34c3b1fe54b73199b113340f8927440b80cda25272e52852dc31b1bee6ce8cb062df67f1c5ef3351a7cb0f15a5ce11be69739aca4371750d1bd506e34a7d0ee61c62fbb6b96431c1ac3ab74d513faecc42ad5c36790f792feb888a7cf2802ed8f5d793a64f66259f8ee4ede989fc5763dc6f91434ba3b1ff5460f71aa7cafdddbd01f09e298be8c407ac959ffc80778d2db69cf46e13490516dbd6d7de101e7fa4946ea163df966b3f44b00200e5fff182b73068341387ec9439e1fb0bd612013704a2a72fd4612fe86c19b8aa1d9ed558ae521e4f384ea96d0b14d8637eb3160f747ee69e727a443918ab58e3b2942dda224cb95a0d10345a3f8fe956c058ce572e3d508bc9c3f8df59ccf9bb2ebb0980d42a6858909137e7baf4ec0c18926c05e3c9179ecb7f10060552f0e6acd2fef09879386fccfb11c76215c11abde13ebb957530df549aafbc74c49d11bc3dc4ebc7cd0699c688bc5a0eefd1c918c75c31aaf0213f1881cc971819dbb1e9f399eb67d91103bd339f5e30b0ef327f98c3bffaf83d8d0ec263075ec860979f57ae519be5bb77cfeda59b1ffaaa761fdccb871515cd20684bc1e5e9688dbc2126107b75afeef4be48c11be6d924ca7d6565dd1fa88d4745c17de7966f0b8eade0f30af7cdedbcfa23fda219448b49093942486f79f68cb41538723e1c99109e50be92f7d59f811a86404ed57240cc9e27efc12dc91452683a83053b6e99d0df48ea6919acfdb4e57ef131535fc99a87f662d0f617d92fac64f3e9cad55662a10a5b81308c642678fd3855f604cc59118ef6539ae01a68ec99f5bcecda471b747df4258e94675b608285652dd7d2bc2810a8fc4d65c6d1e1b1082ffea766ad746640c29d77d44cddbd49a02510a9f466cfdbb95b9788437b206042ab81137c347e1780f10add6b45eee6ab0dc84b1d6c0e1112ff17ea786cee3760a0e0c1f6d7b3318f9ae3fbb99603abb3e466787182d3a70a76723820a81b04059899b034bdfd01b4816ab06de6c7d6a8e364ee38e2663c83bc208e52441d080adefa194f3f8f3bc0903611c9fc72414fabaa49a3fd06bb54a5f57121c030368f392a8f52d7cb7bab12ec09d749f8dd215b7400be64ace1bb0ade0e4462ccc9321dfa10e4a7f6c664e5983fad24df2b06cf055efa0a2230f7b1d777207a013e9d6c9106ea9534bc1b3d3e2c28cb91669b3ad8e43a9b4b44b4f3b641f4cb922df0b4e8a6e9372cfdc323c49f494ef9910762810e7d42768e3d48d6dd1e4c74386b68699a5077d88a05b5ce99c9015d3db1168a8644bc7acc0f98e57db52b0bd5e3a0f48b47b637fef65fb64b9601d8673962f4b0a6afba05f9ce643928b05ea0e22e1a919a29e6c3020013a93aa4cf4b6ef2e9da0357d3660d66e89491d4432ccc1d9277cb2c4e6d0288a1e9fe1ea18cc30672644cdfddc26c1174dda4d80e699e83579d7f7c61ca01c566b9ba33b55e124c0c619d80054210a578edc13e22fbf360af442a8e1b0e9262b9a829d33b3732a2f88e36e2798436f5f05fae725217a8ff37393ac01c7d15f37c615bcddd8f2d3ee784afd1954c4c8bdb048ab7dc10915047634178b132deaf40ec7b8b2b7d8d1c55a9095ec6cb61dd4f5716c12dbb56b925382ef61708e99fa4b7110f53b43b70d3c6d5cab1506801816c4bdeac5d4dc2082804733afacc19a7904033ea3f3a9f2d463b502aabf4d8a2e6d575f09a92e0bdad2680f09a99a3213724975dbb7f8a4a26a3b91f58fdb568e072eff3f961af13f3de7acb69d21066714d8c5a6c047b76b7cbe51bed6579471895494b3008a753378b20396e7c9802dc2a5ec05e67b4616301a5bb54365a07e1f84e3d609e636cba0592bdf05d80db7d1614ea6d07758c0777a74f32499e2be8321385c1e99c5fa5f9badb8e95548c1964c8886c670ce5548bc73c997e5db147dfc2b083b12aa20bbe0a6fae8c1cc17adf6a9edb378ac5634bec1af47acad59bab04e62da0c4af88611a9e128f20b0ec614429bc85613e1b0ddba85adb214f2dc053be1e8cac63734061267d7b8a222b5562c3a5bc0cb5f3c76257600f11fdbfb684d640f204fbd87fdd75937a44d20a36b2bdc821c1e3ea09e955bc2975f7a070f5a06d6ddb899e3ece6a7b6251159685e19d04543fd3e6976204dcee271bb4d7b84c4d6f9f8046be377189e6e3968516c7cd3be46e91ef9a1044d73f7d57b0aa348133162c163172ece395fb090ddb50db7d61c7bc791d15dde68a35765083e9e86f3da0f6d713d65672a2b53e56256df79d397a09b78b48af7bff6fc956ff9c764aad8a0d46e8d2be9bfcb1af6fe24d0a715a8f297db5473d5f088f151be8db7cf3248d23ff216e532a757233c64be4c6fd19626802dcac85b26caa02a2e01ac4a6037873a13b5b9f570c5b14e8752ba6094f481c4d698a16dd695057ec56a3ca26c93a5d96bdae94b69c63d5ae32c945c19319a1939c81f0d02d781e56a328b8c2e85731e2d6c2ca9ba26fcd6c87c6b8db49783f280c022594f11210e6a0ba6ff44eeec236e32d848d99ad5a408659a372f74cde9fbafc8598e01d9422072dbf54446b6d74400d5fe1c62211e5f1c9d5069e15797a0d1eefa549e4629a352f4aaad951d7be1359fca1cf64eebeb5856d73a88d696db837dc7cfc15cb7d337be71a154acc9f620cbf8448b42b486ddf3d55c8ba4c0137354f626148e198d584a3ac67dd43b636d119fb16af027ecbe17a54be6a4fefaa749fa201b33f273e4f0f0a7165c625e86c978e1c691ddf44f35746eb31d5e536b59cf7db13da6925d89e5da5388d1fdfd4b39805416dc26825932288e125cea26069d23206aef22622fbc75f5018f6db58c5441e0a8049d76953cd47814760d2fbc3173e37fdf5ee465d0c6bd339feb4d7a751c663df731fd2622bf242cb1736a46cde82a2373a50d6f63cc564b5e53ac9d41a19e1de585b8152f578116594d6504d8c5471cfbf037dcb1f66cd652b9bd5a6e303464d67c570e10a836a82d258d31a021317dc518252e20a6b6bfa583856bfe46fac33c1431aaa1563207632f04c61e27e7987565fba41f1a1d2d6d989eb90742fb3f818c4b1442cbdb11fd49c8d8640eb408d925499e2e4256958caa49937c2747daedb18c40fa97f24793df07fb128a7ec3848685633d3cf9494abb07cda9a92985f26b14b21c47bef3ad139d5edfed423e8318ea3fbe6dc3fd097bf31636ad31eb49590754882975dffe7bfe0d3dbd6d6efaf90807fe767ea500461dabd78357ac79df86b85f8c0a420164b0a5e0d9269a92a83db405b06ca4d5817180cfa49bb3b0d0d49b8b472281e387bcdd55170d6db336962066cdd1afc18f3bea2432ff56e1b189c129a448b1e60e9447f44e521b68ffa98ee1d70d14cd41bcf8d7febe283633bd4c68a76631e3a485eb15300ce9da4f4f5f6848386e0541aa4411f87cca901bf2f6d07e710f2e6324c7530c9863443deeb7c007ea4dd946f49c53a7e5be5685b0027dc81fb3c5402e162db2c9d40afd2b8cbe5900413c91be160c9408a990f46c7deebc46c5d6d4a0eea8fe8a4c1a63d8a4433d83e87bef1f22fbe7c667555d2857f719b3d861264283975d15b0d15bdc8896175c4b33a58dca74ee033659eab0b34bfeab223c4f7e397d50ad9da4681c8b3a73aa8da8262fd4cd62ae8f73147dd14ef2f1be5ba2a3ffebeb81322e77a60715af5096a88c269b28aa9fa5c0a4649b4ae34f667c591a98fb5ba669e8fc6823328f4805ecd5e2ccac472865e8086f1fe7b55e6c597f8beaf30093d74279c0e76925eb78a07586e3b410ab1a1870c1fbc41d52da96ee1207df26c123e05498ac63965ec33f255e8eac1382771994378e5fa0352682d85bc8b01509240b67adb21138425893c3f60f794cb812e8ce3557be0857efc2a0e77ed8a9bbcc7463b1b11085f3ccf2d80dc32c503f661769d44b8c5d9be4331df4d77361d14413a0c9c8e0e10db6dc448305bfc199c1873e4c48d57e29e3c0370f13482d3fdf86fb476af69d936760236accbdfe6d80815dbb0e4191ba90759325c41b7692d11da36476d5809eba92bf83fa4cfe2ecd49445e2174e9b4c726431aae4dcd4bf826c5794bc3ab574cb0b573f2c8da196b22287514efd280d1ed70ea590d2aba48ae5de0988343e0db6e623bf62b7be98abab36872cb44e2eadeb7ff50f943550c082dc5ab6928c84fd647625f87cf74a133142f1128203e303f8651d537a747f084f80954ffc1a12c7f0b85a0cf8734ae4d4c3a000f656aef26ac3d31d98a02b64cc1625345c768a173de9b2c7beade73b906b60d16a19bbe7f733a944f917f77fa0927bcca81dd25f5f7bee76f68b3aaa7b5054e4e0b63d71fd56e64a849ae5324f3473c5370a09d8896d268a288ade725da1a254057bb9d61d9e4137381d4f768f9e8ccf43096ca665ea075dd2628c5b807b6e18eedc8e0c8110fee75d0c3a06625bf08e00e32358c102c69c2c7bda37d60f56c416584f0a5c30b4923636bb9a68ed06cfce0fb4419342e8b97a4a6abd62e3210aa8afe854a9e12aa6378eb53cb7d3a60ca832981c29bb480a1b6fb94d448726ecaea2afb780c014566536d0761942d188ecc6265d3f98a7d43d871dce92d28bbf89a06866f78f4582ac442e7642345d9e7e230071f1fd679e0385c06996f46c455fc0fe6f9b5cc4990a55460057d4f6588279e246958e715aaf932360654e356e08d50bfdd0c35e3139e4c0f9908712467f393cd04e65de32d24823e4e93b209b7e1f98e2c0418b924108644fde64c6b151fbd189ee3d095de14eb88bd60257e1ace5c1cf9d9d1b0a14e38a3006048047e0486acc182186e801a387017418bb43c545544e7707385328019b3f141bdd2c59517ddf7651f7cccf45cf7c82746407d3216a3c","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9b29ac021091fa45ce1d1f414a45dd24"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("invalidPass").classList.remove("error");
            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    document.getElementById("invalidPass").classList.add("error");
                }
            });

            document.getElementById("staticrypt-password").addEventListener("input", function (e) {
                if (e.target.value !== '') {
                    document.getElementById("invalidPass").classList.remove("error");
                }
            });
        </script>
    </body>
</html>
