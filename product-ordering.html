<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Vickie Yim | Product Ordering Tool</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="shortcut icon" href="img/favicon.png">

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-page {
                width: 100%;
                padding: 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-page .locked {
                width: 1.1rem;
                margin-right: 0.5rem;
            }

            .staticrypt-form {
                position: absolute;
                z-index: 1;
                background: #ffffff;
                color: #212121;
                width: 360px;
                top: 50%;
                left: 50%;
                margin-right: -50%;
                transform: translate(-50%, -50%);
                padding: 2rem;
                text-align: left;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                color: #212121;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 0.9rem;
                outline: 0;
                padding: 1rem 2rem 1rem 1rem; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                width: 100%;
                border: 1px solid #9e9e9e;
                margin: 0 0 1rem;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #424242;
                width: 100%;
                border: 0;
                border-radius: 0;
                padding: 0.9rem;
                color: #ffffff;
                font-size: 0.9rem;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active {
                background: #212121;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
                font-family: "Circular STD", "Gotham HTF", "SF Pro", "Arial", sans-serif;
            }

            .staticrypt-body {
                width: 100%;
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1rem;
                background: #f5f5f5;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                width: 100%;
                display: inline-flex;
                align-items: center;
                margin-top: -1rem;
                margin-bottom: 0.5rem;
            }

            .staticrypt-title {
                font-size: 1rem;
                color: #424242;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .error {
                display: block !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            #invalidPass {
                display: none;
                color: #ff5555;
                margin-top: 1rem;
            }

            .nav {
                position: absolute;
                top: 0;
                right: 0;
                display: inline-flex;
                align-items: center;
                padding: 2rem 3rem;
                padding-right: 3.15rem;
            }

            .nav a {
                text-transform: uppercase;
                font-size: 0.94rem;
                font-weight: 600;
                margin-right: 1.6rem;
                color: #bdbdbd;
                text-decoration: none;
                line-height: 1.9rem;
            }
            
            .nav a:hover {
                color: #616161;
            }

            .nav a.active {
                color: #212121;
            }

            .nav a:nth-last-of-type(1) {
                margin-right: 0;
            }

            @media (max-width: 26.75em) {                
                .nav {
                    left: 0;
                    display: inline-flex;
                    justify-content: space-between;
                    padding: 2rem 3.15rem;
                }

                .nav a {
                    font-size: 1.15rem;
                }

                .desktop {
                    display: none;
                }

                .staticrypt-form {
                    width: 70vw;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <header class="nav">
			<a href="index.html">Work</a>
			<a href="ideas.html">Ideas</a>
			<a href="about.html">About</a>
		</header>

        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">This page is password protected</p>
                        <p></p>
                    </div>

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="ENTER" />

                        <span id="invalidPass" class="error">Incorrect password, please try again</span>
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d57fb7819e05b0516015baeecc8600efc545e4fd38959b12edb33edea44e3b4efd4294537e844ae0f53d1871c41e4c44141544fbe1286ca465e21ccbe1e1457e2c89cb7cc2f2b73b00f7f1c6116dc3803f437157984b61cb926c02135124042916872e0e525d703e9030553d4b1005e69673d45de1d7acf83fe598e57b37f044140bf3e20eff88179a74943e91f7f6f8f863b8d3afdcccbfd9c1b6cfce44dac6182b596530977e2b6d909ac8978ed7980857eef5019bfab3469c851f65b9a88d23dcc641e1047caf1bab7f81e67b1565572f0c715d3d1947a6e82e4c9ce520ac2b1d12fcacbf39f05e12b783e033f6bd51f768b2c177a1cfaee8a133835ca5799b82e4ab08177cc88163624f0e3d041cbe7a5f160110fe963b0934fdfc02632365ff45f02714b6845360dfa1d7ead8473d7529e5464ab4be9527119da9c900b1cd08a4e0302179437ecbc4ec746db65ddfb40a0058d6566863a0d76e549e682d3463258649acfa7fd184b1c4dc23092db916417b6ead4e6c4a040b36bfc7a0bd68f29955d535e07de0a7fc0826388cf40e150c7c25fcf0bf535c0305fbb6e3e079005a029c35d5f53dc5e6e33bd0be05b75efe5cf3657d414844bcc4f7174064b02e6b21f7ba7c3767c82685db2414143e9f0aefb39eaf0943f784ff918ef5279e294521924a009827ea9dca958b4b7b7c27b8e7d3d2694641aaba87c0d6d17f64ec11b136240eb77c112ab09cb8bc95a67397b7c70cd98fffc3a5a9955e792add2721b5dbc74bf0296e0ea1c658376897c585df31a0099971b156587b22efbc2c7aa00af4c17b3ff642a9b0f6d61c1cc1215d882977e60575a5b93dae7ca7b4950e71087f4a2da7a1d3e1e10b595f939d3527a2444dce5deef5f0ecd1b78bd76d967e8bc1a5a4502bffe488a5b16c276196d329ad8062a54c9220d917a3fa56082084ddc8a44294574267aba3a7883574d02f82b81b20bdb335a797c762f9add59080829c1a403342b05cd4c9c10bf94554682d534fb58a73f31dcf564943fa3bd59d51ed519370fa163f8a3625de264c0678eb78cc710219fd8ad2b3f997b0771ed2e0b2f9af80be8f677fed97a6ddf0dc54e810d7940f15751763cb8c72dd9a7c0b3d59d2c465c4194248e8ae3359f16236f751b2f17f308dd381065aff7dfe966a8c5754e9f13fa49943450f95a53301a557aefb29aac1dac5e0aca4b8c4a7e312763db0ab0696841f12f6f57cdb1750979d69d6de48f52a64e444f7a7c1bee177c34f1b114ebd83329198c0792a3e53d300db95805bef984bc879ea1b852535642857b76cdc69baff3819c4275a844a81119d5ed583fff4b8bbffc65dcf2e0bac85d3d293a2c7f9074bd64efefc2ec58d32d305023a4a947b0ec68fb85b9ded83930dc4662d0e71190e59b07ed1803a49b490c658383152e33c3423394e74e5d8934015a2f8ab346d159e542daafb197aba9803856fed7fa236d4e746b547d1fd93afc70b1e3f2ce9ca35064e7d8f553e52f873689fcd620774ad3a801fd34808eac0ca40922c8e912edc96a8a44e6d7a7be0a04a2831f3721ed190a82bacac27faf0c5b5f056b5701a703e6a2aeed3c95cbd6314aa39033eb1e324f1b48164f5535083e5a9b1326c015b61bdac92305326aac77c24b333512dac856f52351373a5dc53ace8b89fc13d08677e5595b77d5b2e92847e917ba068af7f81cd85869ef50d54e1e4fc0cf385a31f7fe9931fafbe94be633145613b3ab84f15214a01f4431aadae3c9e301d9774fb3e84ebfc4f80efda8df631b5ad7237cee4626ad8af7c22688328abd70876917e3db3876fc4394c0c3c275ce6187d7c4bb7f3a246ce9116b64a6a2cdd2befe3abed88f09d9d162ea80ee955dea6e9780d82553a03e350decb5f42e9b3750918a2e0895a2f8679f6aaad242acf2c69174632aed525c40b5ad601e43c8ec61a5d3fa547259491cbb78bf4944c20bc32916cfbeeb2db241b9f45e96237adcd821661ebdcd14efb14cdabd2e71ac8a4b1838c97a8f5ec37430ef5db80024db523ab7260f6ea7ad1f702df052801082564ec7cc6e76b109792bd7051e33fc5c73ee862aa16875d9f9c478fe919574d271a6344b4a53d856b5da4440c5375ab7abe3d2e9f4713c6a1968315e5f0ab05ebfd96a66e90ab84ec9ae8dddeba4936c94694967333733b4c5caa168d8cee4b5345db6d3b2114bfbea9ef1fc575163df693048b76768bd4f63c620d8d71b0f420d07d2b027847337ca863505e47f49980623d5e25bd79eb4b286434023a18085d9d23c64b985e5a8332d0d9f2b18adb0baaaead73477edbc63755115c039ef87e52ffb99abbf304f4974a7ce00bc24aa792291424730842573875f8c8aa3bba001fa8ba817ae8c4b7fba72a7e78f7bc94cc66b0011ce88ed930ab591cd101eda1e4962ee6216d794b70a69c9e8400632fd4f8944739edf81cacd52fb4f92dc97c9bd40c1890ef3e64ba321dbfd571e506630805dddf3f1d89c268b840e5d70418d0f8cad7dc952d7dc08d6480e85aebacc06116e47cab9b0d9a313e7de304dcad0cda8b1d860aa5fb81d05518be7f872ebe4b87078bfe832f774ba012ebf8c2aebf656aaf16d59441acafe5937e1af1a1cfab882dadfec5977a84000a6fe65fb7fca21cbef6765807b4c084ade1a3606022716f9d1df9404317bb0317e0b90596101c5f939d78e94adbd0929ff6f5eaa13c6eabe48f8711f59223b7e3d940be18269df8015505bf48a6ec613bd6a147d1652bbbe9bd714015bb420cca9c9949ff97352f1913d6e6560800add1297adb35ac76df423e60077f91e7b6a56a33ece1c5b6760b0e3efb344574569a1b18ee26bd10410256004f8c4f597d54f7798fd2fe4bf581a01d257969f066c7879cbd10303005349a0f2fcf6a2356fba5e2c11a2fb29b3e1e2ca5c63ff91980980a05b96512ef414b59d9e08959336dc69873d0911a4c0732064930d54c6cc7a5dfc7811f1ef03a8ae256c83265e8e35946ac5603b2adc21cb10bf8363b7f630d24b53b2b2ac32e41d5e761a4193d208396696646e8ff4d84e28f3a0364de753e7049472cd81141b6761561c2fd630352f0ac085c0d7618a433a31b692a0b7bae739fe02f3c3cd74dce0abe9aef476b912db51b480cee49d41d3b8ee76babfbbad8d260b2bab2f137a17f27674dc82bfb3a72d2c7f8f1f31468e3a901bcd4461806ec73fb47dccab3cc1df0f63bf494d4270f6ef8f054a2bd74388241538071fa153ce5be4faf48d388b1812eab304fdc0962a3764fc02d03221fe8c92200f79ba75d33e4759ee30c5c4be655c4ac7eb8a97beeab855fd3aa59d2156430eb2c8d2a6980d54f9b695f677cc3416fe2082fb0ba71791d29f4650f734ce64ffb82f0a180be6c47207b78306d7b407d831930b01ae139ae7f2349f98adb55fe449813a94786fdc58c842ba48d6304d8e93efa1ac2fbb5deeac84cd00b27e6d93243697c839d2df332d160609505c5bbd0c381fa1ae17b38451013cff47f0a223da0ba270789e8a6d46f1c21616456a4b6a37f80bd1415e82a29363ea4fa9073a421e8c87b9edc93d9d22ee1ccca4848e796fb94ca54893f459308eee098c72fe6c7961d2c7496b837b4388506eede88c92ccd0e2c5b7e1237884b3baabece7bfce198ce6ccb9cd38d7e06b4627e1524d92b4ad57ca106ab8a33db057bc4b46fb676d9b7ec60ef1447306a3316a076477da2d93163c91ee1c440d1b304e8388c3a129c93aef8f7f102b77d7ef75951d07bffec58b8e654523be97eb50629573d7178d4f652e6526b4a870addec8adbbe63422df1971c243ecf2c628c08a9d4213e8195cde9d2ea62e8c592dd93e032ab9b80375d4bba7728b5919b3ba1ac413aabee70c4c1b728786b44d44a6aea7e88a476fdcc3bf4885a72623b988ad0037047709a289b1288c1a9c0e1f49a6655e057d6a716f9bc3ec3a61d91b4559d0825a94eedd313f65f38b9ed4c1e81e8f67892e5a62a3c4a3d22791d3982c6aa55968fdf911d812851455c9e894889e3869ff3974fcbff74790fdfddcd7ce9bde035fe2ca376535bf5b099b2643688c8138bdc02c53064e62f3d5522217bbda949ecac09d919c3d4765985324c75fc23b7dac00a69c8ca61d38f7eae697f01902462489ce188973cebd74e740de0a75c59b8d5bc5e010e415cbbb0e8a4e9f3e267d2d5853cd133b58a697b2264d2da086727fe024ef8a454720b5a75607c17e3a05f9225cf8a77e5ab4f63e6bb12753aa1bc63c3e589a5ec08c555483ec4846eff16a95ea8f6aa1d772cae77a202d28f26f609ccb3e42b86b64058324a30a15b126c59c12f4538fd16dd21d4655262b23521d6494c2cc1e4b7ab5fe37de4b654b04cd79369b03ef375dbbda4c47427eb219c78cb00f58fc7bc229e906ef790fe1ec4e6f2184ff675c924891589d10a953e0c895ceb9af1de899d70fd6e05646b5f02ae6b480f18247e027157d14d81adc0c885d4d2275411cc43d104a8420e58c7821bb2a254481d67b4b132f18be6658453ae22df0b307c0807c48fc94d7bd85d0c57e2d95e65d38a8cc4deb19f7ce16049341b38faeb7a69e4313771558701ec9c4cbec25b0772188d3241ad897eb6d872e3cf527a85fba01ee4febdd335d875232c84cd3041541aef9a4346bf0c7ce244407f28cb261e24b6a39a07b80fc7660b2da95775123eba689c65fce42536f6c31fc8e58df96e1117db47b726fff03d5098373d67637a3afa38cc70a1170750c60b74c23c1712638092f94e77c1191c153c4b6a49f9def81cdfa8303f76194db212693b308c57e462de29a418355977ae883f4e2ff55cf12b123ac5b7c37a22b8e356ac4e493d54e345e4ca7e2590d6779b900b202f2a75e2d99b132da980398208ce90d221f01e23eac2b14382a403ee64b3f72baa1030b878c02694929d5fa4f245ee0a49d37aea631defd8de0fa0e18c8ef107e6828989cf4198c64595e8a5fc69d8182c08c132491722d347102b57f0aacde397ef9d11c81bda21366e5646410bbb587bebe7ceded29b467b375e01035b0396c5026b43e8b1ce98820d79d0572675ecc39c605b5501f33110022b9c33fd2c1809323175df118b8a6757e9c725bdc74c29bd757e01f6cde29f51e1be8738433d03a7f6eb1f1691bba6489a279bbd326b79b76b654828021f9c2eb5a18c116225a8c1dc73bb9ec78afc478e72a2f873266f74670ac50472f6201a53bde0b09a21975e599b6ff15a0adf0f5cd0cdf5cd2fd201848fd48d316e77dfe631b3c300c5b0a0c66d92a3b18146f358264fb9ed4c755eeea711819a23d3172029202406e56749b7485f9c02250ab0844c41145b483e6dbeaa982e711d5958f97b2eff3113921abd302effa649a823d8a87ce51af76910816365bc148a6d9a86b4318399d2084fac4157056ff176a949904443e78fa5b6dd12fe243dc95652e1298ee5d99deb8a930cbc8065cb4c17e0ca32ad8e8ff99a376513947305918900d4cdd0e50589ff8b55366dc956c2a241ef8d8292130ff3c3edfd9e801d8c8ec1641c7873531ea331a1a6c75334a1b586849b57923bbafc14a11d9bdddab46fe6612a0498703fef24bb246a0f0d4342bcffa407ffec7cd00fc4f5adda2e7ba2a1c98c4e5074a243e93a0d8843761b8cef4302b80cf2c7291813c2efa1aaea5d6654357f093a79eebcfe3d4504d42377023aa3114a60066e3fae96d6c753087a5e809348363c74040dce9a0d77df95b213aafe7d8d3252504f375d443e90000030e2ffe9596f5a9d10f8ad66aec5c8f43a446a18edc2d305f38fa0739176254b2136b493ac6fbbf7716626023286ec0141ea7033ab5668f0c65818b69f94a5ba3844dc88148fd359a878d9327c4feaa7217752aca3a36bef50b7429178458eb2ff08ba9b1a8f16ce9b03cfbc8a945cd95d53c4a82a8dec0625df92103bdf76a1b1b5d7ab7c3a9ddb8d5ade6f1ae622a9391646d67c3e8bcfa1db6b6744ff336147cc6a9299df34d2245360fe0bc76dc2c39fbf2ff6bb0add09afc228801c25ae5e82c07ca3666c5dc5e99643afd1655c5c1d7a3e27ef2235092b1dcde65f0baa44ea235d49412bf7dc093b7cb405cd4db79e66588402ba591a4651484429fc101c63c5532918f3969868c2fa30ae8788c35bfdd7d02145efb117f703916ecf06742c4d70d8391ed6454954394ac096d24621590f5419fd1c0bfb9861c8056ce31938a5f23c3dc5951dc93dc2dbeb8c5fdd353e452a3142eb9c5b2f0e52b8386baf6c93242f0a7911bb66a5bcb7bb76dab0ac0d3f9c9f1971830183ddb7879f6deedf79b848dadbf6e1158ba31bde375922a5d2aa94f57211a921e557ada558155980f863814b0b1b7488e88945fdddfce7b01239fda9299b18e0bed4a5316546a0c6df71538fde612e12502482355be65f32e848cc4fe8de1261f61b465da37a5f0536c1e7fa220855a0c3fa98d5359429d14c38230bc39c629deaad6246c61cb47a032c21f771a6398e6c04e65ae59fe1dc1bfc87d4a350576dbaf6f140d2ea16746b6a9a3f253f11183bcac14bdc7e4083327773345280f498c0e4bf86eefc3ad1def168047b80461d452daf6265bdcef16fb04072360612e5bd85cdf418faee539b46dd8c4790920acc477e9e18bbf69c73ebaf65cfecf6877c0d3874be3d446878850d48f4625270b7a03cf163b5a65da4a2870e28bb96ce54a00a1fa778c8d102874ed1c727dc5a9e80a6a53c3d0c0b920d16e94d445340fb9035a8d907228d4702f9030f401593577beb8962b89abf3be7f6488dcef159b887cc8bf2f96db8b63d4ca785ad2afe835d24372c8c638cac297af39a6240b7f6a7a78ec797d06d428541d4e357e4e22f201581146c8a737a7d823dd693bc528d464bd0d107d3ac0a583c86c97a3a126ae4d23c7c08c8a2834395d8dd988e47ca2d4a8f3bf26c18e0d294fc6c2796b48bb4b66f2c902083ff358a35471f9dcc0b776519376676a94c883dcf2abfd3fb604acc6b3d7f2b8b9f2fe6fb71ab61c1d0ba550e26550620b859cc11e6eb2125fa171bf179858e42b71253f965883a8e7169f8dabc44176b3444ff6dd5fd22457d324bac73a3100fde90615cbb169287150941e9143132d8a8c14329880fb562de7e3f71dbd0bbb99d9b9174ce165e7d415a243b6d24299f09ffb6fc2c3266e99c64c9e5746ed0105c7de01f90984aef226eee06065e6ae4e1a5544f4fef4146268dab2b5b4557f608414310f94f9c7237cf174d51b315bee4b49405082355fc03ddbdc2e1a96a99b30962dd11f389e7bd3c71b7ab88e5b8aca874110c81ddf0eca36e2a877aff18e8a6d8469e849b5b6ec4643f4903c4ebb20b0d4bd7a4b17dc685f2ab512021c5df69d5dd48279e91f8eeba6fc1e2ab21dcc519d91347a123ad1985086436bc4da1909e74e59e34d6c5d75717f763e39d8b5e9f98182b02915ebbab4b9fb6e0fe95c1bde7a11577923032083a2a1a8b28c2ee6c0f6d57b4ce4fc5195254f34c01b8992336724032e148d0bc1f5bf1bced2df0309ce8381e15876da5362aefa6af16eb0480975d33d93e764d50687004e09e2302ef66544179f650659f2b3f7518068862fbc31129a3835359b5a8c4bcfc8edd61b30a752f79e0cacf9bb9f44e5c39c737e31c918fc3fad860e472da7bf3d52ef2f25c9da4314a46d8d0148be1d746657ae3704f34b9131065497994d87d27ca97e128fa8579cf2920d357f76a962cfecea270429a096fca83a6b564fe255d99eaa7a789aeb708d7ef89cb6145b96d0c42b499e89262aec997a43d65b6db4bb44194a9deae691a9d062d1b60eea49ebd54bcdbb1cbd3d8a3f7b71f12a8272405b1db687d4d141067fc3b5a4e30c3bb2e0f60366d4fbdbfe3847b48e4ea1a65b938dac63b5eba5047621915e395e4c0794360dc761a82b5c33afc83fd1023f75b560182bc2b4f3970a65085a9e85be0c370e1d6acbccdde7cbf0c6f429f571ddde7c1ae3d38a6733f79f09b59e4895a01bfd62065bf1693a11c2798476d2a2281ff59f7cc471c83942d83d7f1b83076f02da6d7a0c91c785cdf581eeedc4edcef086d5f1333520d9b6955eb8069d428f143760f3fe34808b3dd8a6913f51cb9eae2bb08255b6ee444a9458e095687cd790c6178f8b817c3de4df72daa9799c3f7f5785466849f0bcd99b5557bfcddb313dde5df9c683de233f626d5bdca17a024eac681d768b035743802145aa6630c55922e988f00b7fd3763c6de84c429858cd9daeee06362f2f0e65039591036367e2bdb57608a91f4ac8014462181f210e46d4efa63a889852b4b46b4c0b95ed66cf1082ebc6f0e22bd61d900843be4e21a28d40f66f54c6ea332ad6396345540c7bcf69b0ae06dcffbdb933085e18b3ef13a0ab2928eebb7134506e8c6b4bf548ae9c9dbeb38f290c3df6793ad674c2dc81a60734ad762e9d5043bcd0b3f9147559c3433fd17a4e4809a60b6792eb198cf173d599da91562d3db7da86c2d1dcdae42a96d2a519c8986e149124a2f302dff266d9cf48afbfc2fc48b45ce4dba38e27b066d15682d3437de69b1a492e700ec2c59088bec952ed75794823f00b0f12276a33c93b08d8a3de93a25153a9617a52a2d1b15416746cd1921b7206890c8c5bf6c4dc05ee8738b8903d90b7f03a9f148655e2ec5fb97c930043c40269acbf48d13a5c1ebb0995722402a9aae9de160e5976b90d834a8047611d85eee4b60a33586dd3623439604d83c9ce18b82fab0c921a464cb4a26bb25fdaf523262a547f238f8b89dc2c292d5e0270ae7d04b726a75eceff94df629a09a69d83198c0f99829d5279536cfe5ddf7f9e112739eb3029996faf8e22c84f37efa8a63214772dfca01b28d1d236d7770e98470388967f7e3ebca4f3df20fff52668150770967ee78002c60f9b3129ce8d72b0dc4d6fa3377126627f0627ea3faf68f1718b42efa62ce9bb8c568a29853a2439be4ae7fad225b582bc1589255682f7a2648821aee52b8be238396a71be641fdd99c111c864e346d104bb9f34b973bb5f34fbda5fc31428343cd5fbed94ab0ac5a42a78f91aa0920429aeecbcbc1af73f81dd004cc6c4815f74988d7bdb420906b21b5f55856270ccfcaa9bee66d11b7e12e008986d75c976ffa062218eedc889a7a8e5d4ac5c8aa4715819ec6216e216c0b1d94800178285262a6b0f7db7614fe99ebbe8029257de0086ae860cb5245b0fb749e67d60e82b7bbc11576d993072274c13d1383949ee94df571b03c5bee36a4ff29a4f8e95a109c86f950562bce4cea5efdf3f6084bba588440b33984c4afbcee4c0deb435834ea1356db9d9286d2fa94387aedd83c6964cd2b077f64a636f63e00611fda056e1a066556cb33de52bd2882ce75159a04799844fbd4f9e83b8a8687715e0664e1083f80a48c4d18f612a254c20b8241b78f3fafed070f219b472a56499eaf5111bd2382ea6443c95ab1e3c11d9a97d5672f216fdd269fe55ee3ee15241236b05a3e1c6550e2ddf7b39c244ac3257cd9ceb894cd9ed3d7fb19c7ead1be8d945bbd4081224b0b69a4fbccf673ce15ab267d6de91cb1bc442943d43e84407ef9eb68808d0630e3a75d559cde7dbdb00ce33742d5370e77d18247fa2b17b53c972fd618bf19e0d29b59012681b78832c5784640b58f31a1615f7d959081d75cc315015a2f92c66ebd2a7f5751abb777e1be122e81a15f29484da08787ae82911a57855f7a62baf2b5f1ebe7f5d21b97b7cccc1e228b416ddb5a2d7afdef6143389188f842b3ae5765a1d1a32dfd3a036e7cbebbdbce451be04aa235131078877a774bd193cceb563f980a547c87ed71357b994b8c8e7626bbafbd40df7d606653acda3eb1808a77c7d1bcacd8c92c139fd96bf31cbada3f361bbf9d16f6ccd65673818573eb171ef5a4182aa2029e8ec6725173d7ec91872f59689eccc37d518f9122136aece5fa11cddc094dbe79438527b86dce3ec0065a34534fca5e2783f2ebb501613255fc1cc3585946e9ab5ed50e20eca27edbad388b3daf188f46f463b4e68d2e5315577df2f3934ccba4c4f734f9529227d32b1503349ae3a5616265bf23ec313d1b034d374d0e7a48faa6898779fe1cc648fef07f535f8baf9445a224178f42d9e30b24e0afe85c5f0197b8cb70c5c8d4c01bdb2214fa304c19eac117e62394beb478046b2370abdd82f4d61492a8301d1f34dc4eec9b57e5f6ff6a510107426047ad5a3fe6edff15ed935b1412923c1fcaae3d0227df7f42ddfa9c03de3180cefcb398107247d71f05f63c782c796c5aef7f888036da0987f8ee79f973984dda9078526844d1eed21ffd733c3a0b1fee82986ef1adba61abcc301339a35b9b1155db60453fface69b238155741bb704d3cb6bc7fbdd4a42de9c6d8acc1d9b4e217fb03b22c2e00e5299a6958ea48567e324057ca8e1f251dd11fdacaaab070f7f4951a318dd59425b3610781cf89068535b69378afe344635578a91b176f469cb880fad99f54b7a18e3986ef14c4995f41fd55c1a7811e40130608a603389b2871ea35cfa30d5207d1ee5c46fec68e150f30758a38d280bd18bd369ca262fdca0dc8ba7c85185e87408881464811c02e61035d0257ee9240c94c637e84ee948b81ffcfb54e43cc8efe954c757280d76a799f710c1316550c72484414b09511dd76fb4f2dc0e5119ed1c9a913892a179725812edd4c6d90a0bdfd0cd9a21ee79363f9af1baf69643d50910da2b89012cf9ba8fc3e2b9e9f5047244f0824266a2b28bfdafb520f03211f1e636afd0906f1fc89d5224990614c2fb9d23abca55dd6b550e748e9d2878c7abad599ac22ad0e45803ae1b3d9a97220bad08bb39b49b708073ac77d580bcf3abc42c82fc480c01286597e47b842da3244ee723d2cc0ddf31b072ffd6183f1b7f0b1157585e524236b12245ebf14aecce0d448d47f22329f75cd83f68c51761e732cd242e9f76c8b31cbd83563bbbe0fa5b1cbea08851254371a75998ac3120eaf3652d7b32b442ea6ca85a5eebd283a1bf8b713a1953219f0c57b3fb3b69310071761cc092c1a2e1f7ab52f2a6555f10a22733d55b567c4a1a8dc24465158b56aae010daffafcf495458945208fcdcb3a8cb9a8b91553b3d33d28fc8643b8fa19a9056be3db4ae42392d8201aa00b83fb43e7392470180b5a9655bed6d44672a128c66890fd073456e86528616a1326d9fc630bda20f43c0ec82a64e889f92a679e449de207f2d5e6900cc25e3c7a038f62c5ed2cc2d04589bc9695c686f866cd1625ef545d11cbc2f162253c5c0a7041487eea738f2f50fab7c04a9bc7ff74e69741aba114f433b5bf55ce1c5aebf1f11fa13741df08a086b617a3707165a02ebaa8afe7c723c9dccdc059fcfc2dfd863c82336c4a37c8348b13f2a64200c2505643b0d0252bac37fbeeecc3966a50c69fd11fe7d8df646d03f9a3beb2f792219e276c55ac558112845298fcbf55e6d5f5d261ee3a5daaa1751a45bdfdba97bd6d89b3bdf626665b5ef430046c2b1fe5bb0eb9f94bf3f7adcb33963bddbf64aa0f9b0d42a3d6deef163c8cdca8e1c761dcd0f230b32cb5d580351fb7862fae3b3c229690ad0d12b1bfb69e91abb6789371fee777aed6bf3f05dd47f27084bbcc4bf7f7a71bce79a95983082e97b2f52c50757c2df748d2bb8dc037e76ac9bfd938d5cd244546d0bc1aee981a88264e2f2547a95d825080099b896288f48183c8039f2a61dc4faf8f401e11d15a72605c6b129738d958b20132f2920ccc410aa5940984b920941c6bb091af1f69924a38d6e0ea443faeb336987b2437dd717a4faaac43f75b52d06d9605d8fec335722eb381c4b69ccd601cc25a66d7a06cc633ee3d1c329c85411e29f10b3c5b2f480cff05027d5dc2e2539993b57c5465550ac8d29009aabf1d4b2408bc22148a46a580e45dcf9755bd6e08ea14dc56c0a32a025539c674e9f8d7639cd2e8a85d253d86258b2e33500cd6a601424e2eb11ed45c3d0fbf561101651a361ce402078b507fe0a2c00c881914ffafb3840ee570ac1b3e1bda88d047d8633c10b02ae0ae365dbfb939b5ec7983724d9ccc77f821c59eda1888e9e37080aab2a3b3b6e43802040d2487d49dfbf4c009c49291731d477efa314ef9ab47d856e4b65f159fad90c09c70329080ee0ccc6e7d87301a4c52486c757f146e102317b48e58c7a30cf4183b2962b5876c5af4bfaad26b46059afb6193b9f7f43f0384858f70d1b3b2d57ae38f77245217c13aa45063edbf16b6dd3685ebc60ccd5d7dfa4175f995028b3f83ed68f9464040619e72e439234f7fe5bb20d398a616aedabd394b701c739be7ac6e5ccb64f8d52db3bca0c483191dffaf8fc4fcd0f5043c768797e4425debe9cdc0f8aca92a8e80e4b1901e7456869cfd70eb983bdbf611e2d381ecd26dc5483f4961af739fcd750dac7fe0cccf55147fecdd136ddf6fd41380502cda843daaed7fea39fd699323e8a7f04040302bee0dcbf9cef379bedc0bf4ba66b8fe75f3d5931cae95c28194bd904785d31dcdf2306489c63c15c4107d29ec2426bed956f1ac9a4050cb7ac894af2d6e4372c26954a599bd7f8539d74117752a959a99089f2556c44419715f47d2877b8d64fe739d63224ee400c4363f82d11fa803b7203d25551db981a6c6b53ec91b324e13a55e6fdb20bb7d31fe0454ea6a6f292de1ed847e1fe4f14687c29f35e1a94f2ac812c9910d7a3724bc0521e168118338175cfc02b67f0496aac5e07b842ca22bd70903d7a8e53c77766359b539fdbb5231b4312957e16164e88e4a3323428c16fc5e08bb9dffb91f85eff8ee2ff170ee90b80adb4ab8b5ff5ad2bc5ea47a27c4b2c7578a3eeb512513328facfae9c77b600a0920dbc321d06c82888a087df7f1fb07e6ae51c7688513616e49a20b59b5760204452a87aef81288ce991de7cfdab40854e082c1f3b4f5e34ac25efea89a63120eb1a483d4b6bf1f44befb13ff2624b2032920f13dba4333c8e30ad1a987ee86da93ecbc0d03329ddf88278fce50d6051504a519e1771557b0cb80c1d14aab9b9b044ad2fc2e66909246f0eededb3f89e9b7fe1f144b060be7c6ad302da3ee8f5e0a1b6305b4be7518762a678500e89f3613c09053fe30fa5403c208f3b1c6daeb2eca6dc37a43cf3fcd1cc3a192afd72aea09a086cdd8c16226d0fbd34ea472b779779e1310b8059c6f7b28cfa6df2d98083ba84e","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"7eba367a8c31c1b50249c4df9d952f2b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            document.getElementById("invalidPass").classList.remove("error");
            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    document.getElementById("invalidPass").classList.add("error");
                }
            });

            document.getElementById("staticrypt-password").addEventListener("input", function (e) {
                if (e.target.value !== '') {
                    document.getElementById("invalidPass").classList.remove("error");
                }
            });
        </script>
    </body>
</html>
